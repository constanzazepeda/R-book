[["index.html", "Guía rápida para aprender R Parte 1 About", " Guía rápida para aprender R Constanza Zepeda 2022-06-02 Parte 1 About "],["vectores-matrices-listas-y-data-frames.html", "Parte 2 Vectores, matrices, listas y data frames P1 Vectores P2 Vectores P3 Tablas P4 Tasa crecimiento P5 Tasa crecimiento P6 Valor presente P7 Muestras P8 Matrices P9 Listas P10 Manipulación", " Parte 2 Vectores, matrices, listas y data frames P1 Vectores Generar un vector que contenga la siguiente secuencia de números: \\(1,2,3,4,...,10\\) seq(1,10,1) #forma 1 1:10 #forma 2 seq(10) #forma 3 c(1,2,3,4,5,6,7,8,9,10) #forma 4 Asigne el vector creado a \\(x\\), determine su tipo y dimensión x &lt;- seq(1, 10, 1) typeof(x) length(x) Calcule la suma y el producto de los elementos del vector \\(x\\) sum(x) prod(x) Calcule la suma acumulada y el producto acumulado de los elementos del vector \\(x\\) cumsum(x) cumprod(x) Construya un vector lógico a partir de los elementos del vector x que son divisibles por 2 ¿Cuántos números son divisibles por 2? ¿Cuáles son divisibles por 2? y &lt;- x %% 2 == 0 sum(x %% 2 == 0) x[x %% 2 == 0] Genere el siguiente vector: “mes_1”, “mes_2”,. . . , “mes_10” paste0(&quot;mes_&quot;, x) P2 Vectores Genere un vector que repita roja cuatro veces y azul tres veces. c(rep(&quot;roja&quot;, 4), rep(&quot;azul&quot;, 3)) # Forma 1 rep(c(&quot;roja&quot;, &quot;azul&quot;), c(4, 3)) # Forma 2 P3 Tablas Nombre Edad Pedro 17 Ana NA Maya 23 Max NA Paula 20 A partir de esta tabla genere un vector \\(x\\) con las edades de los estudiantes. Los nombres de cada uno de los elementos del vector deben ser los nombres de los estudiantes. x = c(&quot;Pedro&quot;=17, &quot;Ana&quot;=NA, &quot;Maya&quot;=23, &quot;Max&quot;=NA, &quot;Paula&quot;=20) Defina un vector \\(y\\) que excluya los missing values (NA). y = x[-c(2,4)] #forma 1 y=x[c(-2,-4)] # forma 2 y=x[c(&quot;Pedro&quot;,&quot;Maya&quot;, &quot;Paula&quot;)] # forma 3 y=x[!is.na(x)] # forma 4 y = na.omit(x) # forma 5 Asigne las edades de Pedro y Ana a un vector \\(z\\). z &lt;- x[c(&quot;Pedro&quot;,&quot;Ana&quot;)] #forma 1 z &lt;- x[c(1,2)] #forma 2 Calcule la media aritmética de las edades de los 5 estudiantes usando la función mean y la fórmula para el cálculo de la media aritmética: \\[ \\overline{x} = \\frac{\\sum^n_{i=1}x_i}{n} \\] mean(x) # ¿Qué obtiene? mean(x, na.rm = TRUE) #forma 1 sum(x[!is.na(x)])/length(x[!is.na(x)]) #forma 2 Calcule la desviación estándar de las edades de los 5 estudiantes usando la función sd y la fórmula para el cálculo de la desviación estándar: \\[ s = \\sqrt{\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^2}{n-1}} \\] sd(x, na.rm = TRUE) # Forma 1 sqrt(sum((x[!is.na(x)]-mean(x, na.rm = TRUE))^2)/(length(x[!is.na(x)]) - 1)) # Forma 2 sqrt(sum((na.omit(x)-mean(x, na.rm = TRUE))^2)/(length(na.omit(x)) - 1)) # Forma 3 Calcule la proporción de estudiantes que tienen 20 años o menos. mean(x&lt;=20, na.rm = TRUE) Calcule el promedio de edad de los estudiantes cuyas edades son 20 años o menos. mean(x[x&lt;=20], na.rm = TRUE) #Forma 1 mean(x[which(x&lt;=20)]) # Forma 2 Escriba summary(x) en el script ¿Qué obtiene? summary(x) P4 Tasa crecimiento Calcule la tasa de crecimiento promedio anual del PIB si las tasas son: 20% y −20% r_g &lt;- c(20,-20) (prod(1 + r_g/100)^(1/length(r_g)) - 1)*100 P5 Tasa crecimiento Si una variable crece a un \\(x%\\) por período, construya una fórmula que le permita obtener el número de períodos para que la variable duplique su valor. Calcule el número de períodos si las tasas de crecimiento son 4%, 6%, 8% y 10%. x = c(4, 6, 8, 10) log(2)/log(1+(x/100)) P6 Valor presente Calcule el valor presente de un flujo de efectivo de $1000 por un total de diez períodos. Asuma una tasa de descuento de 10%. El valor presente \\((VP)\\) es igual a: \\[ VP = \\sum^{T}_{t=1}\\frac{F_t}{(1+r)^t} = \\sum^{T}_{t=1}F_t\\times (1+r)^{-t} \\] r = 0.1 #tasa de descuento flujo_efectivo = 1000 #flujo por período n=10 periodo = 1:n #períodos valor_presente &lt;- sum(flujo_efectivo * (1 + r) ^ -periodo) paste0(&quot;Valor Presente&quot;, &quot;=&quot;,&quot;$&quot;, round(valor_presente,0)) #forma 1 paste0(&quot;Valor Presente&quot;, &quot;=&quot;,&quot;$&quot;, round((flujo_efectivo/r)*(1 - (1 + r)^-n),0)) #forma 2 Calcule el valor presente neto de un flujo de efectivo de $300, $1200, $1000 y una inversión inicial de $900. Asuma que las tasas de descuento para cada uno de los períodos son 10%, 20%, 15%, respectivamente. \\[ VPN = -900+\\frac{100}{1.1}+\\frac{1200}{1.1\\times 1.2}+ \\frac{1000}{1.1\\times 1.2\\times 1.15} = 940.58 \\] # Tasa de interés r &lt;- c(0.1, 0.2, 0.15) # Factores de descuento yearly_discount_factors &lt;- (1 + r) ^ - 1 yearly_discount_factors discount_factors &lt;- c(1 , cumprod(yearly_discount_factors)) discount_factors # Definir vector de flujos cash_flow &lt;- c(-900, 300, 1200, 1000) # Calcular valor presente VPN &lt;- sum(cash_flow * discount_factors) paste0(&quot;Valor Presente Neto&quot;, &quot;=&quot;,&quot;$&quot;, round(VPN,0)) Calcule el número de períodos en que se recupera la inversión (payback period) del flujo de efectivo de $300, $1200, $1000 y una inversión inicial de $900. paste0(&quot;Payback period = &quot;, min(which(cumsum(cash_flow) &gt;= 0)) - 1) P7 Muestras \\[\\begin{align*} skewness &amp;= \\frac{\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^3}{n}}{\\left[\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^2}{n} \\right]^{\\frac{3}{2}}}\\\\ kurtosis &amp;= \\frac{\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^4}{n}}{\\left[\\frac{\\sum^n_{i=1}(x_i-\\overline{x})^2}{n} \\right]^{2}}\\\\ \\end{align*}\\] Genere una muestra de 10000 números aleatorios provenientes de la distribución normal estándar y calcule la skewness y kurtosis, usando las siguientes fórmulas: z = rnorm(10000) skewness &lt;- (sum((z - mean(z))^3)/length(z))/(sum((z - mean(z))^2)/length(z))^1.5 kurtosis &lt;- (sum((z - mean(z))^4)/length(z))/(sum((z - mean(z))^2)/length(z))^2 moments::skewness(z) moments::kurtosis(z) P8 Matrices Sea X una matriz : \\[ X = \\begin{bmatrix} 0 &amp; 10 &amp; -5\\\\ 5 &amp; 8 &amp; -4\\\\ 0 &amp; 1 &amp; -1 \\end{bmatrix} \\] Construya la matriz X y asigne nombres a sus filas y columnas. a &lt;- c(0,10,-5) b &lt;- c(5,8,-4) c &lt;- c(0,1,-1) X &lt;- rbind(a,b,c) # Forma 1 rownames(X) &lt;- c(&quot;fila1&quot;, &quot;fila2&quot;, &quot;fila3&quot;) colnames(X) &lt;- c(&quot;columna1&quot;, &quot;columna2&quot;, &quot;columna3&quot;) cbind(c(0,5,0), c(10,8,1),c(-5,-4,-1)) # Forma 2 e = c(0,10,-5, 5,8,-4, 0,1,-1) matrix(e, nrow=3, ncol=3, byrow = TRUE) # Forma 3 Almacene la segunda fila de X en el vector \\(z\\). z &lt;- X[2,] Almacene los elementos (2, 3) y (3, 3) en el vector \\(w\\). w &lt;- X[c(2,3),3] P9 Listas Genere una lista que consista del vector a igual a {8, 12, 16,. . . , 36}, un vector b que contenga las palabras hola y ¿Cómo estás? y un elemento c que contiene el número 5. lista_A = list(a=seq(8, 36, 4), b=list(&quot;hola&quot;,&quot;¿Cómo estás?&quot;), c = 5) Obtenga el primer elemento de la lista. lista_A[[&quot;a&quot;]] # Forma 1 lista_A$a # Forma 2 lista_A[&quot;a&quot;] # Forma 3 Obtenga los primeros dos elementos de la lista. lista_A[1:2] Asigne “¿Cómo estás?” a s lista_A[[&quot;b&quot;]][2] # Forma 1 lista_A[[&quot;b&quot;]][[2]] # Forma 2 P10 Manipulación La siguiente tabla presenta la distribución por zona de una muestra, separando entre hombres y mujeres: zona hombres mujeres A 800 700 B 200 300 C 700 600 D 300 400 Construya dicha tabla como un data frame. zona &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) hombres &lt;- c(800,200,700,300) mujeres &lt;- c(700,300,600,400) muestra_total_df &lt;- data.frame(zona, hombres, mujeres) # dataframe Construya dicha tabla como un tibble. muestra_total_tb &lt;- tibble::tibble(zona = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;), hombres = c(800,200,700,300), mujeres = c(700,300,600,400)) Escriba en el script \\(summary(muestra_total_tb)\\) ¿Qué obtiene? summary(muestra_total_tb) Escriba en el script \\(str(muestra_total_tb)\\) y \\(dplyr::glimpse(muestra_total_tb)\\) ¿Qué obtiene? str(muestra_total_tb) dplyr::glimpse(muestra_total_tb) Presente las primeras tres y últimas dos observaciones del \\(muestra_total_tb\\). library(dplyr) muestra_total_tb %&gt;% slice_head(n = 3) muestra_total_tb %&gt;% slice_tail(n = 2) Extraer la columna \\(mujeres\\). muestra_total_tb$mujeres # Forma 1 muestra_total_tb %&gt;% pull(mujeres) # Forma 2 Construya una tabla con las observaciones de las variables \\(zona\\) y \\(mujeres\\). muestra_total_tb %&gt;% select(-hombres) # forma 1 muestra_total_tb %&gt;% select(zona, mujeres) # forma 2 Construya una tabla con las muestras de las zonas \\(A\\) y \\(C\\). muestra_total_tb %&gt;% filter(zona==&quot;A&quot; | zona==&quot;C&quot;) # Forma 1 muestra_total_tb %&gt;% filter(zona %in% c(&quot;A&quot;,&quot;C&quot;)) # Forma 2 Construya una variable \\(muestra_total\\) que sea igual a la suma de \\(hombres\\) y \\(mujeres\\) y una variable \\(prop_muestra\\) que representa la proporción de la muestra total de una determinada región. muestra_total_tb &lt;- muestra_total_tb %&gt;% mutate(mayor = if_else(muestra_total &gt; 1000, &quot;alto&quot;, &quot;bajo&quot;)) muestra_total_tb Genere una variable que toma el valor “alto” si la muestra total de una zona determinada es mayor a 1000 e igual a “bajo”, si no son mayores. muestra_total_tb &lt;- muestra_total_tb %&gt;% mutate(mayor = if_else(muestra_total &gt; 1000, &quot;alto&quot;, &quot;bajo&quot;)) muestra_total_tb Guarde muestra_total_tb con extensión \\(.csv\\). readr::write_csv(muestra_total_tb, file = &quot;datos/muestra_total.csv&quot;) "],["importación-de-datos.html", "Parte 3 Importación de datos P1 Importar datos P2 Retorno P3 Retorno P4 Bitcoin P5 Farmacias P6 Poblacion", " Parte 3 Importación de datos library(dplyr) P1 Importar datos Importe los datos del archivo loan.xlsx. Se recomienda revisar https://www.lendingclub.com/ y https: //es.wikipedia.org/wiki/Lending_Club para mayor información. library(readxl) loan50 &lt;- read_xlsx(&quot;datos/loan.xlsx&quot;) loan50 %&gt;% glimpse() P2 Retorno Obtenga datos del precio de la acción de Netflix para el período 01/01/2018 hasta el 24/03/2022 desde Yahoo! Finance. Además, calcule el retorno diario de la acción usando las siguientes fórmulas: \\[\\begin{align*} r_t &amp;= log(p_t)-log(p_{t-1})\\\\ r_t &amp;= \\frac{p_t-p_{t-1}}{p_{t-1}} \\end{align*}\\] library(readr) nflx &lt;- read_csv(&quot;datos/NFLX.csv&quot;) nflx &lt;- nflx %&gt;% mutate(retorno_log = log(Close) - log(lag(Close)), retorno_arit = (Close -lag(Close))/lag(Close)) P3 Retorno Obtenga datos del precio de la acción de COPEC, Falabella y Latam para el período 01/01/2018 hasta el 24/03/2022 desde Yahoo! Finance. Además, calcule el retorno diario de la acción, usando la siguiente fórmula: \\[ r_t = \\frac{P_t-P_{t-1}}{P_{t-1}} \\] library(tidyquant) stock_prices &lt;- tq_get(c(&quot;COPEC.SN&quot;, &quot;FALABELLA.SN&quot;, &quot;LTM.SN&quot;), get = &quot;stock.prices&quot;, from = &quot;2018-01-02&quot;, to = &quot;2022-03-25&quot;) retorno &lt;- stock_prices %&gt;% group_by(symbol) %&gt;% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = &quot;daily&quot;, type = &quot;arithmetic&quot;, col_rename = &quot;retorno_arit&quot;) %&gt;% ungroup() stock_prices &lt;- stock_prices %&gt;% group_by(symbol) %&gt;% mutate(retorno_diario = (adjusted - lag(adjusted))/lag(adjusted)) %&gt;% ungroup() P4 Bitcoin Obtenga datos del precio del bitcoin para el período 01/01/2016 hasta el 25/03/2022 desde la página web de la Federal Reserve Bank of St. Louis (FRED) (https://fred.stlouisfed.org/series/CBBTCUSD) bitcoin &lt;- tq_get(&quot;CBBTCUSD&quot;, get = &quot;economic.data&quot;, from = &quot;2016-01-01&quot;, to = &quot;2022-03-25&quot;) P5 Farmacias Entre al sitio https://datos.gob.cl/dataset/farmacias-en-chile y obtenga el listado de farmacias a través del territorio nacional. library(jsonlite) farmacias &lt;- fromJSON(&quot;https://farmanet.minsal.cl/index.php/ws/getLocales&quot;) farmacias %&gt;% glimpse() P6 Poblacion Usando el paquete WDI, obtenga datos de población, PIB per cápita ajustado por paridad de poder de compra, expectativa de vida al nacer y coeficiente de Gini para todos los países incluidos en la base de datos en el período 1960-2020. library(WDI) library(readr) # Población - SP.POP.TOTL # PIB per cápita - NY.GDP.PCAP.PP.CD # Life expectancy at birth, total (years) (SP.DYN.LE00.IN) # Gini index (World Bank estimate) (SI.POV.GINI) wbData &lt;- WDI(indicator=c(&quot;SP.POP.TOTL&quot;, &quot;NY.GDP.PCAP.PP.CD&quot;, &quot;SP.DYN.LE00.IN&quot;, &quot;SI.POV.GINI&quot;), country=&quot;all&quot;, extra = TRUE, start=1960, end=2020) write_rds(wbData, file = &quot;datos/wbData_1960_2020.rds&quot;) wbData %&gt;% glimpse() "],["importación-de-datos-1.html", "Parte 4 Importación de datos P1 Importar datos P2 Nombrar variables P3 Ordenar datos P4 Cambiar nombres P5 Contar P6 Identificar P7 Identificar P8 Identificar P9 Estadística descriptiva", " Parte 4 Importación de datos library(WDI) library(readr) library(dplyr) library(janitor) library(skimr) library(kableExtra) P1 Importar datos Obtenga los datos contenidos en el archivo wbData_1960_2020.rds wbData1 &lt;- read_rds(&quot;datos/wbData_1960_2020.rds&quot;) P2 Nombrar variables Nombre a las variables SP.POP.TOTL, NY.GDP.PCAP.PP.CD, SP.DYN.LE00.IN y SI.POV.GINI como population, gdppc, lifeexpectancy y gini respectivamente. wbData2 &lt;- wbData1 %&gt;% rename(population= SP.POP.TOTL, gdppc = NY.GDP.PCAP.PP.CD, life_expectancy = SP.DYN.LE00.IN, gini = SI.POV.GINI) P3 Ordenar datos wbData2 &lt;- wbData2 %&gt;% arrange(country, year) P4 Cambiar nombres Cambie los nombres de las regiones a español. Por ejemplo, cambie la región “Middle East &amp; North Africa” a “Medio Oriente y Norte de Africa”. wbData2 &lt;- wbData2 %&gt;% mutate(region = recode(region, &quot;East Asia &amp; Pacific&quot; = &quot;Este Asiático y Pacífico&quot;, &quot;Europe &amp; Central Asia&quot; = &quot;Europa y Asia Central&quot; , &quot;Latin America &amp; Caribbean&quot; = &quot;América Latina y el Caribe&quot;, &quot;Middle East &amp; North Africa&quot; = &quot;Medio Oriente y Norte de Africa&quot;, &quot;North America&quot; = &quot;Norteamérica&quot;, &quot;South Asia&quot; = &quot;Asia del Sur&quot;, &quot;Sub-Saharan Africa&quot; = &quot;Africa Subsahariana&quot;)) P5 Contar ¿Cuántos países tiene la base de datos?, ¿Cuántos países por región tiene la base de datos? wbData3 &lt;- wbData2 %&gt;% filter(region != &quot;Aggregates&quot;) %&gt;% droplevels() # Número de países wbData3 %&gt;% distinct(country) %&gt;% count() # Número de países por región wbData3 %&gt;% group_by(region) %&gt;% distinct(country) %&gt;% count() %&gt;% ungroup() %&gt;% mutate(prop_region = round((n/sum(n))*100, 1)) %&gt;% adorn_totals(&quot;row&quot;) P6 Identificar Identifique los 10 países con mayor crecimiento de su población entre los años 2018 y 2019. wbData3 %&gt;% group_by(country) %&gt;% mutate(crecim_poblacional = round(((population -lag(population))/lag(population))*100, 2)) %&gt;% ungroup() %&gt;% filter(year == 2019) %&gt;% select(country, crecim_poblacional) %&gt;% slice_max(crecim_poblacional, n = 10) P7 Identificar Identifique los 10 países con menor PIB per cápita el año 2019 wbData3 %&gt;% filter(year == 2019) %&gt;% select(country, gdppc) %&gt;% slice_min(gdppc, n = 10) P8 Identificar Para cada una de las regiones del mundo, determine los valores mínimos y máximos del PIB per cápita el año 2019. Además, identifique los países con los mínimos y máximos del PIB per cápita en cada una de las regiones. wbData3 %&gt;% filter(year ==2019) %&gt;% group_by(region) %&gt;% select(region, country, gdppc) %&gt;% slice_min(gdppc, n = 1) wbData3 %&gt;% filter(year ==2019) %&gt;% group_by(region) %&gt;% select(region, country, gdppc) %&gt;% slice_max(gdppc, n = 1) P9 Estadística descriptiva Para cada una de las regiones del mundo, presente una tabla con estadística descriptiva del PIB per cápita para el año 2018. wbData3 %&gt;% filter(year == 2018) %&gt;% select(region, gdppc) %&gt;% group_by(region) %&gt;% skim() %&gt;% yank(&quot;numeric&quot;) %&gt;% select(-c(&quot;skim_variable&quot;, &quot;n_missing&quot;, &quot;complete_rate&quot;, &quot;hist&quot;)) %&gt;% kbl(booktabs = T, digits = 0, linesep =&quot;&quot;, col.names = c(&quot;Región&quot;, &quot;Media&quot;, &quot;Desv. Est.&quot;, &quot;Min&quot;, &quot;p25&quot;, &quot;p50&quot;, &quot;p75&quot;, &quot;Max&quot;)) %&gt;% kable_styling(font_size = 10, latex_options = c(&quot;striped&quot;, &quot;hold_position&quot;)) write_rds(wbData3, &quot;datos/wbData3_final.rds&quot;) "],["gráficos-estáticos.html", "Parte 5 Gráficos estáticos P1 Grafico de lineas P2 Gráfico de barras P3 Gráfico de torta P4 Gráfico de barras P5 Gráfico P6 Gráfico de cajas P7 Histograma P8 Función de distribución P9 Gráfico de dispersión P10 Gráfico de dispersión", " Parte 5 Gráficos estáticos library(dplyr) library(forcats) library(ggplot2) library(ggthemes) library(RColorBrewer) library(ggfittext) library(treemapify) options(scipen=999) wbData3 &lt;- readr::read_rds(&quot;datos/wbData3_final.rds&quot;) P1 Grafico de lineas Grafique la evolución de la expectativa de vida al nacer para Chile, Japón y Estados Unidos en el período 1960-2020 usando un gráfico de líneas. # aesthetic wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, col = country)) + geom_line() Ejercicio 1: Incluya el layer theme_classic() ¿Qué obtiene? wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, color = country)) + geom_line() + theme_classic() Ejercicio 2: Reemplace colour = country por linetype = country ¿Qué obtiene? wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, linetype = country)) + geom_line() + theme_minimal() Ejercicio 3: Use otros themes que incluye el paquete ggthemes ¿Qué cambios observa? wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, color = country)) + geom_line(size = 1) + theme_wsj() Ejercicio 4: ¿Cómo incluir tus propios colores para la línea que representa cada país? (Ayuda: ver scale_colour_manual()) wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, color = country)) + geom_line(size=1) + scale_x_continuous(breaks = seq(from = 1960, to = 2020, by = 10)) + labs(title = &quot;Expectativa de vida al nacer&quot;, subtitle = &quot;1960-2020&quot;, caption = paste0(&quot;Fuente: Elaboración propia en base a&quot;,&quot;\\n&quot;, &quot;World Development Indicators.&quot;), x = &quot;Año&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + scale_colour_manual(name = NULL, values = c(Chile = &quot;#1b9e77&quot;, Japan = &quot;#d95f02&quot;, &#39;United States&#39; = &quot;#7570b3&quot;), labels = c(&quot;Chile&quot;, &quot;Japón&quot;, &quot;Estados Unidos&quot;)) + theme_tufte() Ejercicio 5: ¿Cómo definir tus propias líneas para representar a cada país? (Ayuda: ver scale_linetype_manual()) wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, linetype = country)) + geom_line(size=1) + scale_x_continuous(breaks = seq(1960, 2020,10)) + labs(title = &quot;Expectativa de vida al nacer&quot;, subtitle = &quot;1960-2020&quot;, caption = &quot;Fuente: Elaboración propia en base a WDI&quot;, x = &quot;Año&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + scale_linetype_manual(name=&quot;&quot;, values = c(&quot;dotted&quot;,&quot;twodash&quot;,&quot;solid&quot;), labels = c(&quot;Chile&quot;, &quot;Japón&quot;, &quot;Estados Unidos&quot;)) + theme_tufte() Ejercicio 6: ¿Cómo se puede personalizar un gráfico? (Ayuda: ver theme()) wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, color = country)) + geom_line(size=1) + scale_x_continuous(breaks = seq(1960, 2020,10)) + labs(title = &quot;Expectativa de vida al nacer&quot;, subtitle = &quot;1960-2020&quot;, caption = paste(&quot;Fuente: Elaboración propia en base a WDI&quot;), x = &quot;Año&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + scale_colour_manual(name = &quot;&quot;, values = c(Chile = &quot;#1b9e77&quot;, Japan = &quot;#d95f02&quot;, &#39;United States&#39; = &quot;#7570b3&quot;), labels = c(&quot;Chile&quot;, &quot;Japón&quot;, &quot;Estados Unidos&quot;)) Ejercicio 7: Usando un rectángulo, marque en el gráfico la década de los noventa. wbData3 %&gt;% filter(country %in% c(&quot;Chile&quot;, &quot;Japan&quot;, &quot;United States&quot;)) %&gt;% ggplot(aes(x = year, y = life_expectancy, color = country)) + annotate(&quot;rect&quot;, xmin = 1990, xmax = 2000, ymin = -Inf, ymax = Inf, fill = &quot;#dba0a0&quot;, alpha = 0.8) + geom_line(size=1) + scale_x_continuous(breaks = seq(1960, 2020,10)) + labs(title = &quot;Expectativa de vida al nacer&quot;, subtitle = &quot;1960-2020&quot;, caption = paste(&quot;Fuente: Elaboración propia en base a WDI&quot;), x = &quot;Año&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + scale_colour_manual(name = &quot;&quot;, values = c(Chile = &quot;#1b9e77&quot;, Japan = &quot;#d95f02&quot;, &#39;United States&#39; = &quot;#7570b3&quot;), labels = c(&quot;Chile&quot;, &quot;Japón&quot;, &quot;Estados Unidos&quot;)) P2 Gráfico de barras Construya el siguiente gráfico de barras que muestra el número de países en cada una de las regiones el año 2018. wbData3 %&gt;% filter(year == 2018) %&gt;% ggplot(aes(x = region)) + geom_bar(fill = &quot;#31a377&quot;) + coord_flip() wbData3 %&gt;% filter(year == 2018) %&gt;% ggplot(aes(x = fct_rev(fct_infreq(as_factor(region))))) + geom_bar(fill = &quot;#31a377&quot;) + scale_y_continuous(limits = c(0,65), expand = c(0,0)) + labs(title = &quot;Número de países por región, 2018&quot;, x = NULL, y = NULL) + geom_text(aes(label= ..count..), stat = &quot;count&quot;, hjust = -0.4) + coord_flip() + theme(rect = element_blank(), axis.text.x = element_blank(), axis.ticks = element_blank()) P3 Gráfico de torta Usando sólo información acerca de los diez países con mayor población el año 2019, construya un gráfico de torta y un treemap para representar el porcentaje de la población que representa cada uno de estos países. wbData3 %&gt;% filter(year == 2019) %&gt;% slice_max(population, n = 10) %&gt;% mutate(prop = round(100*population/sum(population),1)) %&gt;% select(country, population, prop) %&gt;% ggplot(aes(x= 1, y = prop, fill = country)) + geom_bar(stat = &quot;identity&quot;, color = &quot;white&quot;) + coord_polar(theta = &#39;y&#39;) + theme_void() # treemap wbData3 %&gt;% filter(year == 2019) %&gt;% slice_max(population, n = 10) %&gt;% mutate(prop = round(100*population/sum(population),1)) %&gt;% select(country, population, prop) %&gt;% ggplot(aes(area= prop, fill = country, label = country)) + geom_treemap(show.legend = FALSE, color = &quot;#FFFFFF&quot;) + geom_treemap_text(place = &quot;topleft&quot;, max.size = 10, padding.y = grid::unit(2, &quot;mm&quot;), grow = TRUE, colour = &quot;white&quot;) + scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1)) + annotate(geom = &quot;text&quot;, x = 0.58, y = 0.01, label = &quot;32%&quot;, size = 6, color = &quot;#FFFFFF&quot;) + annotate(geom = &quot;text&quot;, x = 0.58, y = 0.58, label = &quot;31%&quot;, size = 6, color = &quot;#FFFFFF&quot;) + theme(axis.title =element_blank(), axis.text =element_blank(), axis.ticks =element_blank()) P4 Gráfico de barras Construya el siguiente gráfico de barras que muestra los 10 países con el mayor PIB per cápita el 2019. wbData3 %&gt;% filter(year == 2019) %&gt;% slice_max(gdppc, n = 10) %&gt;% ggplot(aes(x = fct_reorder(as_factor(country), gdppc), y = gdppc, label = paste(&quot;USD&quot;, round(gdppc,0)))) + geom_col(fill = &quot;#013e63&quot;) + scale_y_continuous(limits = c(0,140000), expand = c(0,0)) + labs(title = &quot;Diez países con el mayor PIB per cápita, 2019&quot;, caption = paste(&quot;Fuente: Elaboración propia en base a&quot;, &quot;\\n&quot;, &quot;World Development Indicators&quot;), x = NULL, y = NULL) + geom_bar_text(position = &quot;stack&quot;, reflow = TRUE, size = 9) + coord_flip() + theme(rect = element_blank(), axis.text.x = element_blank(), axis.ticks = element_blank()) wbData3 %&gt;% filter(year == 2019) %&gt;% slice_max(gdppc, n = 10) %&gt;% ggplot(aes(x = fct_reorder(as_factor(country), gdppc), y = gdppc, label = paste(&quot;USD&quot;, round(gdppc,0)))) + geom_col(aes(fill = region)) + scale_y_continuous(limits = c(0,140000), expand = c(0,0)) + scale_fill_brewer(name = NULL, guide = guide_legend(nrow = 2), palette = &quot;Set2&quot;) + labs(title = &quot;Diez países con el mayor PIB per cápita, 2019&quot;, caption = paste(&quot;Fuente: Elaboración propia en base a&quot;, &quot;\\n&quot;, &quot;World Development Indicators&quot;), x = NULL, y = NULL) + geom_bar_text(position = &quot;stack&quot;, reflow = TRUE, size = 9) + coord_flip() + theme(rect = element_blank(), axis.text.x = element_blank(), axis.ticks = element_blank(), legend.position= &quot;top&quot;) wbData3 %&gt;% filter(year == 2019) %&gt;% slice_max(gdppc, n = 10) %&gt;% mutate(highlight = case_when( region == &quot;Este Asiático y Pacífico&quot; ~ &quot;Este Asiático y Pacífico&quot;, region == &quot;Medio Oriente y Norte de Africa&quot; ~ &quot;Medio Oriente y Norte de Africa&quot;, TRUE ~ &quot;Otra región&quot;) ) %&gt;% ggplot(aes(x = fct_reorder(as_factor(country), gdppc), y = gdppc, label = paste(&quot;USD&quot;, round(gdppc,0)))) + geom_col(aes(fill = highlight)) + scale_y_continuous(limits = c(0,140000), expand = c(0,0)) + scale_fill_manual(name = NULL, values = c(&quot;#013e63&quot;, &quot;#9A4343&quot;, &quot;#C5C5C5&quot;)) + labs(title = &quot;Diez países con el mayor PIB per cápita, 2019&quot;, caption = paste(&quot;Fuente: Elaboración propia en base a&quot;, &quot;\\n&quot;, &quot;World Development Indicators&quot;), x = NULL, y = NULL) + geom_bar_text(position = &quot;stack&quot;, reflow = TRUE, size = 9) + coord_flip() + theme(rect = element_blank(), axis.text.x = element_blank(), axis.ticks = element_blank(), legend.position= &quot;top&quot;, legend.text = element_text(size = 8)) P5 Gráfico Construya el siguiente gráfico que muestra la mediana del PIB per cápita por región en el año 2018 wbData3 %&gt;% filter(year == 2018) %&gt;% group_by(region) %&gt;% summarise(median_gdppc = median(gdppc, na.rm = TRUE)) %&gt;% ggplot(aes(x = fct_reorder(as_factor(region), median_gdppc), y = median_gdppc)) + geom_segment(aes(xend = region, y = 0, yend = median_gdppc), colour = &quot;#878787&quot;) + geom_point(colour = &quot;#b06b12&quot;, size = 2) + scale_y_continuous(limits = c(0,80000), expand = c(0,0)) + labs(title = &quot;Mediana del PIB per cápita por región, 2018&quot;, caption = &quot;Fuente: Elaboración propia en base a WDI&quot;, x = NULL, y = NULL) + geom_text(aes(label = paste(&quot;USD&quot;, round(median_gdppc,0))), hjust = -0.1, size = 3) + coord_flip() + theme(rect = element_blank(), axis.text.x = element_blank(), axis.ticks = element_blank()) P6 Gráfico de cajas Usando un diagrama de caja, compare la expectativa de vida al nacer entre las diferentes regiones del mundo para el año 2018 wbData3 %&gt;% filter(year == 2018) %&gt;% ggplot(aes(x = region, y = life_expectancy)) + geom_boxplot(fill = &quot;#9A4343&quot;) + labs(title = &quot;Expectativa de vida al nacer&quot;, subtitle =&quot;2018&quot;, x = NULL, y = &quot;Expectativa de vida al nacer (años)&quot;) + coord_flip() + theme_classic() P7 Histograma Construya un histograma que represente la distribución del PIB per cápita el año 2019 wbData3 %&gt;% filter(year == 2019) %&gt;% ggplot(aes(x = gdppc)) + geom_histogram(binwidth = 5000, col = &quot;#ffffff&quot;, fill = &quot;#800000&quot;) + scale_x_continuous(expand = c(0,0), limits = c(0, 140000), labels = function(x) x/1000, breaks = c(0,25000,50000,75000,100000, 125000)) + scale_y_continuous(expand = c(0,0)) + labs(title = &quot;PIB per cápita alrededor del mundo&quot;, subtitle = &quot;2019&quot;, x = &quot;PIB per cápita (miles de dólares)&quot;, y = &quot;Frecuencia&quot;) + theme_classic() P8 Función de distribución Construya la función de distribución acumulada del PIB per cápita para el año 2019 # ecdf: empirical cumulative distribution function wbData3 %&gt;% filter(year==2019) %&gt;% ggplot(aes(x = gdppc)) + stat_ecdf(geom = &quot;step&quot;) + scale_x_continuous(labels = function(x) x/1000, breaks = c(0,25000,50000,75000,100000, 125000), expand = c(0,0)) + scale_y_continuous(expand = c(0,0)) + labs(title = &quot;PIB per cápita mundial 2019&quot;, subtitle = &quot;Distribución acumulada&quot;, x = &quot;PIB per cápita (miles de dólares)&quot;, y = &quot;Proporción de países&quot;) + theme_classic() P9 Gráfico de dispersión Use un gráfico de dispersión de la expectativa de vida al nacer y PIB per cápita para el año 2018 wbData3 %&gt;% filter(year==2018) %&gt;% ggplot(aes(x=gdppc, y=life_expectancy))+ geom_point(alpha = 0.4, size = 0.8) + labs(title = &quot;Expectativa de vida al nacer versus PIB per cápita&quot;, subtitle = &quot;2018&quot;, caption = &quot;Fuente: Elaboración propia en base a WDI.&quot;, x = &quot;PIB per cápita (dólares)&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + theme(panel.background = element_blank(), axis.line = element_line()) wbData3 %&gt;% filter(year==2018) %&gt;% ggplot(aes(x=gdppc, y=life_expectancy))+ geom_point(alpha = 0.4, size = 0.8) + scale_x_log10() + labs(title = &quot;Expectativa de vida al nacer versus PIB per cápita&quot;, subtitle = &quot;2018&quot;, caption = &quot;Fuente: Elaboración propia en base a WDI.&quot;, x = &quot;PIB per cápita (dólares)&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + theme(rect = element_blank(), axis.line = element_line()) P10 Gráfico de dispersión Use un gráfico de dispersión que muestre la relación entre la expectativa de vida al nacer y PIB per cápita para los países de América Latina y el Caribe, Europa y Asia Central y Este Asiático y Pacífico el año 2018. Use facet_grid para mostrar un gráfico por región. wbData3 %&gt;% filter(year==2018, region %in% c(&quot;América Latina y el Caribe&quot;, &quot;Europa y Asia Central&quot;, &quot;Este Asiático y Pacífico&quot;)) %&gt;% ggplot(aes(x=gdppc, y=life_expectancy))+ geom_point(alpha = 0.4, size = 0.8, col = &quot;#9A2121&quot;) + labs(title = &quot;Expectativa de vida al nacer versus PIB per cápita&quot;, subtitle = &quot;2018&quot;, caption = &quot;Fuente: Elaboración propia en base a WDI.&quot;, x = &quot;PIB per cápita (dólares)&quot;, y = &quot;Expectativa de vida al nacer (años)&quot;) + facet_grid(cols = vars(region)) + theme_minimal() "],["gráficos-dinámicos.html", "Parte 6 Gráficos dinámicos P1 Gráficos varios P2 Gráfico de barras P3 Gráfico de barras P4 Gráfico de mancuernas P5 Gráfico de lineas P6 Gráfico Bitcoin P7 Precios YahooFinance P8 Retornos mensuales", " Parte 6 Gráficos dinámicos library(ggplot2) library(treemapify) library(waffle) library(dplyr) library(forcats) library(ggalt) library(tidyquant) P1 Gráficos varios Usando datos que se presentan en la siguiente tabla, construye un gráfico de barras y torta. df &lt;- tibble( categoria = c(&quot;B&quot;, &quot;A&quot;, &quot;D&quot;, &quot;C&quot;, &quot;E&quot;), prop = c(34,31,20,9,6) ) Barras df %&gt;% ggplot(aes(x= categoria, y = prop)) + geom_bar(stat = &quot;identity&quot;, fill = rgb(0.6, 0.26, 0.26), width = 0.8) + theme_classic() df &lt;- df %&gt;% mutate( categoria = fct_reorder(as_factor(categoria), prop), highlight = case_when(categoria == &quot;B&quot; ~ &quot;1&quot;, categoria == &quot;D&quot; ~ &quot;2&quot;, TRUE ~ &quot;3&quot;)) df %&gt;% ggplot(aes(x= fct_rev(categoria), y = prop)) + geom_bar(stat = &quot;identity&quot;, fill = rgb(0.6, 0.26, 0.26), width = 0.8) + theme_classic() df %&gt;% ggplot(aes(x= categoria, y = prop, fill = highlight)) + geom_bar(stat = &quot;identity&quot;, width = 0.8) + geom_text(aes(label= paste0(prop, &quot;%&quot;), hjust = 1.3), size = 5, color = &quot;white&quot;) + scale_y_continuous(limits = c(0,36), expand = c(0,0)) + scale_fill_manual(values = c(rgb(0.04,0.07, 0.26), rgb(0.6, 0.26, 0.26), rgb(0.81, 0.81, 0.81))) + labs(title = &quot;Ventas por región (porcentaje)&quot;, caption = &quot;Total 100%&quot;) + theme(panel.background = element_blank(), plot.title = element_text(size = 14, color = &quot;#636363&quot;), plot.caption = element_text(size = 13, color = &quot;#AD9F9F&quot;), axis.ticks = element_blank(), axis.text.x = element_blank(), axis.text.y = element_text(size = 12, color = &quot;#AD9F9F&quot;), axis.title = element_blank(), axis.line.x = element_line(size = 0.3, color = &quot;#AD9F9F&quot;), legend.position = &quot;none&quot;) + coord_flip() Torta df &lt;- df %&gt;% arrange(desc(categoria)) df$ypos &lt;- cumsum(df$prop) - 0.5*df$prop df %&gt;% ggplot(aes(x= 1, y = prop, fill = categoria)) + geom_bar(stat = &quot;identity&quot;, color = &quot;white&quot;) + coord_polar(theta = &#39;y&#39;) + geom_text(aes(x = 1.1, y = ypos, label = paste0(prop, &quot;%&quot;)), color = &quot;white&quot;)+ scale_fill_manual(name = &quot;&quot;, values = c(A = &quot;#66c2a5&quot;, B = &quot;#fc8d62&quot;, C= &quot;#8da0cb&quot;, D = &quot;#e78ac3&quot;, E = &quot;#a6d854&quot;)) + theme_void() + theme(legend.position = &quot;none&quot;) Waffle vals =c(`A`= 31,`B`=34,`C`=9,`D`= 20,`E`=6) waffle(vals, rows = 5, size = 1, colors = c(A = &quot;#66c2a5&quot;, B = &quot;#fc8d62&quot;, C= &quot;#8da0cb&quot;, D = &quot;#e78ac3&quot;, E = &quot;#a6d854&quot;), title=&quot;Ventas por región (porcentaje)&quot;) Treemap df %&gt;% ggplot(aes(area= prop, fill = categoria, label = categoria)) + geom_treemap(show.legend = FALSE, color = &quot;white&quot;)+ geom_treemap_text(place = &quot;topleft&quot;, min.size = 2, padding.y = grid::unit(1, &quot;mm&quot;), grow = FALSE, colour = &quot;white&quot;)+ scale_x_continuous(limits = c(0,1)) + scale_y_continuous(limits = c(0,1)) + scale_fill_manual(values = c(A = &quot;#66c2a5&quot;, B = &quot;#fc8d62&quot;, C= &quot;#8da0cb&quot;, D = &quot;#e78ac3&quot;, E = &quot;#a6d854&quot;))+ annotate(geom = &quot;text&quot;, x = 0.605, y = 0.59, label = &quot;31%&quot;, size = 6, color = &quot;#FFFFFF&quot;)+ annotate(geom = &quot;text&quot;, x = 0.605, y = 0.01, label = &quot;34%&quot;, size = 6, color = &quot;#FFFFFF&quot;)+ annotate(geom = &quot;text&quot;, x = 0.99, y = 0.01, label = &quot;20%&quot;, size = 6, color = &quot;#FFFFFF&quot;)+ annotate(geom = &quot;text&quot;, x = 1, y = 0.65, label = &quot;9%&quot;, size = 6, color = &quot;#FFFFFF&quot;)+ annotate(geom = &quot;text&quot;, x = 1, y = 0.92, label = &quot;6%&quot;, size = 6, color = &quot;#FFFFFF&quot;)+ labs(title = &quot;Participación de ventas por región&quot;, caption = &quot;Fuente: Elaboración propia&quot;) + theme(plot.title = element_text(size = 14, color = &quot;#636363&quot;), plot.caption = element_text(size = 10, color = &quot;#AD9F9F&quot;), axis.title =element_blank(), axis.text =element_blank(), axis.ticks =element_blank()) P2 Gráfico de barras Usando datos que se presentan en la siguiente tabla, construye gráficos de barras. df2 &lt;- tibble( year = c(2017, 2017, 2018, 2018, 2019, 2019, 2020, 2020), sexo = c(&quot;Hombres&quot;, &quot;Mujeres&quot;, &quot;Hombres&quot;, &quot;Mujeres&quot;, &quot;Hombres&quot;, &quot;Mujeres&quot;, &quot;Hombres&quot;, &quot;Mujeres&quot;), total = c(100, 80, 50, 150, 90, 180, 110, 150) ) df2 %&gt;% ggplot(aes(x= year, y = total, fill = sexo)) + geom_col(position = &quot;dodge&quot;, width = 0.8) + scale_y_continuous(expand = c(0,0)) + theme(panel.background = element_blank(), plot.title = element_text(size = 14, color = &quot;#636363&quot;), plot.caption = element_text(size = 13, color = &quot;#AD9F9F&quot;), axis.ticks.x = element_blank(), axis.ticks.y = element_line(size = 0.3, color = &quot;#AD9F9F&quot;), axis.text.x = element_text(size = 12, color = &quot;#AD9F9F&quot;), axis.text.y = element_text(size = 12, color = &quot;#AD9F9F&quot;), axis.title = element_blank(), axis.line = element_line(size = 0.3, color = &quot;#AD9F9F&quot;), legend.position = &quot;top&quot;) df2 %&gt;% ggplot(aes(x= year, y = total, fill = sexo)) + geom_col(position = &quot;fill&quot;, width = 0.8) + scale_y_continuous(expand = c(0,0)) + scale_fill_manual(name = &quot;&quot;, values = c(rgb(0.04,0.07, 0.26), rgb(0.6, 0.26, 0.26)))+ theme(panel.background = element_blank(), plot.title = element_text(size = 14, color = &quot;#636363&quot;), plot.caption = element_text(size = 13, color = &quot;#AD9F9F&quot;), axis.ticks.x = element_blank(), axis.ticks.y = element_line(size = 0.3, color = &quot;#AD9F9F&quot;), axis.text.x = element_text(size = 12, color = &quot;#AD9F9F&quot;), axis.text.y = element_text(size = 12, color = &quot;#AD9F9F&quot;), axis.title = element_blank(), axis.line = element_line(size = 0.3, color = &quot;#AD9F9F&quot;), legend.position = &quot;top&quot;) P3 Gráfico de barras Grafique la función de densidad de probabilidad para una variable x que tiene una distribución normal con \\(\\mu = 0\\) y \\(\\sigma = 0.5, 1, 2\\). Nota: La función de densidad de probabilidad de una variable \\(X\\) con distribución normal es: \\[ f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}} \\hspace{5pt} -\\infty &lt; x &lt; \\infty \\] ggplot(data.frame(x=c(-5,5)), aes(x)) + stat_function(fun=dnorm, args=list(mean=0, sd=0.5), geom=&quot;line&quot;, colour=&quot;red&quot;, size=1) + stat_function(fun=dnorm, args=list(mean=0, sd=1), geom=&quot;line&quot;, colour=&quot;black&quot;, size=1) + stat_function(fun=dnorm, args=list(mean=0, sd=2), geom=&quot;line&quot;, colour=&quot;blue&quot;, size=1) + scale_x_continuous(breaks = seq(-5,5), label = seq(-5,5)) + scale_y_continuous(expand= c(0,0)) + annotate(geom = &quot;text&quot;, x = 1.5, y = 0.75, parse = TRUE, label = &quot;mu==0 ~ &#39;,&#39; ~ sigma == 0.5&quot;) + annotate(geom = &quot;text&quot;, x = 2, y = 0.3, parse = TRUE, label = &quot;mu==0 ~ &#39;,&#39; ~ sigma == 1&quot;) + annotate(geom = &quot;text&quot;, x = 3, y = 0.15, parse = TRUE, label = &quot;mu==0 ~ &#39;,&#39; ~ sigma == 2&quot;) + annotate(&quot;segment&quot;, x = 1.5, xend = 0.4, y = 0.72, yend = 0.65, colour = &quot;black&quot;, size=0.6, arrow=arrow(length = unit(0.15, &quot;cm&quot;), type = &quot;closed&quot;)) + annotate(&quot;segment&quot;, x = 2, xend = 1.3, y = 0.27, yend = 0.2, colour = &quot;black&quot;, size=0.6, arrow=arrow(length = unit(0.15, &quot;cm&quot;), type = &quot;closed&quot;)) + annotate(&quot;segment&quot;, x = 3, xend = 2.6, y = 0.12, yend = 0.1, colour = &quot;black&quot;, size=0.6, arrow=arrow(length = unit(0.15, &quot;cm&quot;), type = &quot;closed&quot;)) + labs(x = &quot;x&quot;, y= &quot;&quot;) + theme_minimal() + theme(axis.text.y = element_blank(), axis.line.y = element_blank(), axis.ticks.y = element_blank()) P4 Gráfico de mancuernas Usando datos de homicidios que se presentan en la siguiente tabla, construye un gráfico de mancuernas. df &lt;- tibble::tibble(country=c(&quot;Región A&quot;, &quot;Región B&quot;, &quot;Región C&quot;, &quot;Región D&quot;, &quot;Región E&quot;), year2018 =c(110, 90, 100, 70, 50), year2022 =c(140, 150, 140, 100, 90)) df %&gt;% ggplot(aes(y=country, x=year2018, xend=year2022)) + geom_dumbbell(size=3, color=&quot;#e3e2e1&quot;, colour_x = &quot;#1b9e77&quot;, colour_xend = &quot;#d95f02&quot;) + labs(title = &quot;Número de homicidios 2018-2022&quot;, x=&quot;Número de homicidios&quot;, y=NULL) + theme_minimal() P5 Gráfico de lineas El valor de una máquina en el año t cuyo valor inicial es \\(A_0\\) y que se deprecia a una tasa de r por año es igual a: \\[ A_t =A_0(1−r)^t \\] Construya un gráfico que muestre la evolución del valor de la máquina, asumiendo \\(A_0 = 3000000\\) y una tasa de depreciación de \\(15%\\) y \\(20%\\). A0 = 3000000 r1 = 0.15 r2 = 0.20 t = seq(0,10,1) y15 = A0*(1-r1)**t y20 = A0*(1-r2)**t data &lt;- tibble::tibble(t,y15, y20) data %&gt;% ggplot() + geom_line(aes(t,y15), lty = &quot;dashed&quot;, size=1) + geom_line(aes(t,y20), lty = &quot;dotted&quot;, size=1) + scale_x_continuous(breaks = seq(0,10,1), labels = seq(0,10,1), limits = c(0,12), expand = c(0,0)) + scale_y_continuous(labels = scales::label_number()) + annotate(geom = &quot;text&quot;, x=10.7, y=601500, label = &quot;r=15%&quot;) + annotate(geom = &quot;text&quot;, x=10.7, y=351500, label = &quot;r=20%&quot;) + labs(x = &quot;Año&quot;, y = &quot;Valor de máquina ($)&quot;) + theme_classic() P6 Gráfico Bitcoin Obtenga precios del bitcoin para el período 01-01-2016 al 11-04-2022. Grafique los precios diarios y la media móvil de 30 días. # Precio del Bitcoin bitcoin &lt;- tq_get(&quot;CBBTCUSD&quot;, get = &quot;economic.data&quot;, from = &quot;2016-01-01&quot;, to = &quot;2022-04-11&quot;) bitcoin %&gt;% ggplot(aes(x = date, y = price)) + geom_line() + geom_ma(ma_fun = SMA, n = 30, linetype = &quot;twodash&quot;, size = 0.8, color = &quot;red&quot;) + scale_x_date(date_breaks = &quot;1 years&quot;, date_labels = &quot;%Y&quot;) + labs(title = &quot;Precio de bitcoin&quot;, caption = paste0(&quot;Fuente: Coinbase, obtenido de Federal Reserve Bank of St. Louis (FRED)&quot;, &quot;\\n&quot;, &quot;https://fred.stlouisfed.org/series/CBBTCUSD&quot;), x = NULL, y = &quot;Precio (US$)&quot;) + theme_tq() P7 Precios YahooFinance Obtenga precios de las acciones de Copec, Falabella y Latam desde YahooFinance para el período 01-01-2012 al 11-04-2022. # Acciones de Copec copec &lt;- tq_get(&quot;COPEC.SN&quot;, get = &quot;stock.prices&quot;, from = &quot;2012-01-01&quot;, to = &quot;2022-04-11&quot;) # Acciones de Falabella falabella &lt;- tq_get(&quot;FALABELLA.SN&quot;, get = &quot;stock.prices&quot;, from = &quot;2012-01-01&quot;, to = &quot;2022-04-11&quot;) # Acciones de Latam latam &lt;- tq_get(&quot;LTM.SN&quot;, get = &quot;stock.prices&quot;, from = &quot;2012-01-01&quot;, to = &quot;2022-04-11&quot;) #latam stocks &lt;- bind_rows(&quot;COPEC&quot; = copec, &quot;Falabella&quot; = falabella, &quot;LATAM&quot; = latam, .id = &quot;id&quot;) Grafique los precios de las acciones para el período 01-01-2010 al 11-04-2022. stocks %&gt;% ggplot(aes(x = date, y = close)) + geom_line() + scale_x_date(date_breaks = &quot;1 years&quot;, date_labels = &quot;%Y&quot;) + coord_x_date(xlim = c(&quot;2012-01-01&quot;, &quot;2022-04-11&quot;)) + labs(x = NULL, y = &quot;Precio de cierre ($)&quot;) + facet_grid(rows = vars(id), scales = &quot;free_y&quot;) + theme_bw() Grafique los retornos diarios para el período 01-01-2019 al 11-04-2022. retornos_diarios &lt;- stocks %&gt;% group_by(id) %&gt;% mutate(daily_retorno = ((close - lag(close))/lag(close))*100) %&gt;% ungroup() retornos_diarios %&gt;% ggplot(aes(x = date, y = daily_retorno)) + geom_line() + scale_x_date(date_breaks = &quot;6 months&quot;, date_labels = &quot;%Y %m&quot;) + coord_x_date(xlim = c(&quot;2019-01-01&quot;, &quot;2022-04-11&quot;)) + labs(x = NULL, y = &quot;Retorno diario (%)&quot;) + facet_grid(rows = vars(id), scales = &quot;free_y&quot;) + theme_tq() Construya un strip chart de los retornos diarios de COPEC, Falabella y LATAM para el período 01-09-2019 al 22-04-2021. retornos_diarios %&gt;% filter(date &gt;= ymd(&#39;2019-09-01&#39;)) %&gt;% ggplot(aes(x = id, y = daily_retorno, col = id)) + geom_point(size = 1, alpha = 0.3, position = position_jitter(width = 0.32)) + scale_y_continuous(breaks = seq(-45,45,10), label = paste0(seq(-45,45,10), &quot;%&quot;)) + scale_colour_brewer(palette = &quot;Dark2&quot;) + labs(title = &quot;Retornos diarios de acciones de LATAM y Falabella (en porcentaje)&quot;, subtitle = &quot;01/09/2019 al 11/04/2022&quot;, caption = &quot;Retorno diario&quot;, x = NULL, y = NULL) + coord_flip() + theme( rect = element_blank(), plot.title = element_text(color = &quot;#6E7172&quot;), plot.subtitle = element_text(color = &quot;#6E7172&quot;), plot.caption = element_text(size = 9, color = &quot;#989898&quot;), axis.line.x=element_line(size = 0.4, color = &quot;#D9D1D1&quot;), axis.ticks.x = element_line(size = 0.4, color = &quot;#D9D1D1&quot;), axis.text = element_text(color = &quot;#989898&quot;), axis.ticks.y = element_blank(), legend.position = &#39;none&#39;) Grafique la densidad de los retornos diarios de COPEC, Falabella y LATAM desde 01-01-2019 retornos_diarios %&gt;% filter(date &gt;= ymd(&#39;2019-01-01&#39;)) %&gt;% ggplot(mapping = aes(x = daily_retorno, fill = id)) + geom_density(alpha = 0.5) + labs(title = &quot;Retornos diarios (en porcentaje)&quot;, subtitle = &quot;Falabella y LATAM&quot;, x = &quot;Retornos diarios (%)&quot;, y = &quot;Densidad&quot;) + facet_grid(cols = vars(id), scales = &quot;free&quot;) + theme_tq() + scale_fill_tq() + theme(legend.position = &quot;none&quot;) P8 Retornos mensuales Obtenga precios de las acciones de Copec, Falabella y Latam desde YahooFinance para el período 01-01-2010 al 11-04-2022. Calcule los retornos mensuales y grafique los retornos de un portafolio compuesto 40% por acciones de COPEC, 40% por acciones de Falabella y 20% por acciones de LATAM. precios_diarios &lt;- c(&quot;COPEC.SN&quot;, &quot;FALABELLA.SN&quot;, &quot;LTM.SN&quot;) %&gt;% tq_get(get = &quot;stock.prices&quot;, from = &quot;2010-01-01&quot;, to = &quot;2022-04-11&quot;) retorno_mensual &lt;- precios_diarios %&gt;% group_by(symbol) %&gt;% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = &quot;monthly&quot;, type = &quot;arithmetic&quot;, col_rename = &quot;ret_mensual&quot;) peso_acciones &lt;- tibble(symbols = c(&quot;COPEC.SN&quot;, &quot;FALABELLA.SN&quot;, &quot;LTM.SN&quot;), weights = c(0.4, 0.4, 0.2)) retorno_mensual_portafolio &lt;- retorno_mensual %&gt;% tq_portfolio(assets_col = symbol, returns_col = ret_mensual, geometric = FALSE, weights = peso_acciones, col_rename = &quot;RetornoPortafolio&quot;) retorno_mensual_portafolio %&gt;% ggplot(aes(x = date, y = RetornoPortafolio)) + geom_line() + scale_x_date(date_breaks = &quot;1 years&quot;, date_labels = &quot;%Y&quot;) + labs(title = &quot;Retorno portafolio&quot;, x = NULL, y = &quot;Retorno mensual&quot;) + theme_tq() "],["mapas.html", "Parte 7 Mapas", " Parte 7 Mapas "],["modelo-de-regresión-lineal.html", "Parte 8 Modelo de regresión lineal P1 P2 P3", " Parte 8 Modelo de regresión lineal library(ggplot2) library(dplyr) library(stargazer) library(broom) library(wooldridge) library(AER) library(sandwich) library(car) P1 La base de datos ceosal1 contiene información, correspondiente al año 1990, sobre 209 CEO. Los datos son usados en el libro “Introducción a la econometría” de Jeffrey Wooldridge. La siguiente tabla presenta las variables y su descripción contenida en esta base de datos. [insertar tabla] Usando estos datos se estimará el siguiente modelo que muestra la relación entre el rendimiento sobre el capital (roe)1 y el sueldo anual que reciben los CEO (salary): \\[ salary = \\beta_0 + \\beta_1 roe + u \\] donde el parámetro de interés es β1 que mide la variación del sueldo anual, en miles de dólares, que corres- ponde a un incremento de un punto porcentual en el rendimiento sobre capital. data(ceosal1) Estime el modelo especificado arriba usando Mínimos Cuadrados Ordinarios, considerando una espe- cificación con constante, otra sin constante y una sólo con intercepto. modelA &lt;- lm(salary ~ roe, data = ceosal1) # modelo con constante modelB &lt;- lm(salary ~ 0 + roe, data = ceosal1) # modelo sin constante modelC &lt;- lm(salary ~ 1, data = ceosal1) # modelo sólo con intercepto stargazer(list(modelA, modelB, modelC), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) Muestre la relación entre rendimiento sobre el capital y sueldos de los CEO, usando un gráfico de dispersión, incluyendo la función de regresión muestral estimada en (a). ggplot(ceosal1, aes(x = roe, y = salary)) + geom_point(alpha = 0.5) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;) + labs(x = &quot;Rendimiento sobre el capital (%)&quot;, y = &quot;Salario CEO (miles de dólares)&quot;) + theme_classic() Muestre que el \\(R^2\\) del modelo A es igual al cuadrado del coeficiente de correlación entre roe y salary. paste0(&quot;R2 = &quot;, round(cor((ceosal1$roe), ceosal1$salary)^2,3)) Use tidy() para crear un tibble con resultados del modelo A modelA %&gt;% tidy() Calcule el intervalo de confianza para β0 y β1 usando un nivel de confianza de 90%. # Forma 1 modelA %&gt;% tidy(conf.int = TRUE, conf.level = 0.90) # Forma 2 tidy(modelA) %&gt;% mutate(lim_inf90 = estimate + qt(0.05, 207)*std.error, lim_sup90 = estimate + qt(0.95, 207)*std.error) %&gt;% select(term, estimate, std.error, lim_inf90, lim_sup90) # Forma 3 confint(modelA, level = 0.90) Calcule los sueldos predichos por el modelo estimado y los residuos augment(modelA) %&gt;% select(salary, roe, .fitted, .resid) Estime el modelo por MCO usando la forma matricial del modelo de regresión lineal múltiple. y = ceosal1$salary x = cbind(1, ceosal1$roe) bhat = round(solve(t(x) %*% x) %*% t(x) %*% y, 3) Obtenga los errores estándar de \\(\\hat{\\beta}\\)’s, usando la matriz de varianzas y covarianzas de \\(\\hat{\\beta}\\). round(diag(sqrt(vcov(modelA))),3) Calcule los errores estándar robustos a heterocedasticidad. round(diag(sqrt(vcovHC(modelA, type = &quot;HC1&quot;))),3) lmtest::coeftest(modelA, vcov. = vcovHC, type = &quot;HC1&quot;) P2 Suponga que estás interesado en estudiar si las siguientes características de una empresa el año 1990 ayudan para predecir los rendimientos de las acciones en el período 1990-1994: dkr es el cociente de deuda sobre capital de una empresa, eps son las ganancias por acción, netinc es el ingreso neto y salary la compensación total del director general. Sea return el rendimiento total de conservar una acción de una empresa durante el periodo de cuatro años que va desde fines de 1990 hasta fines de 1994. El modelo estimado es: \\[ return = \\beta_0 + \\beta_2 dkr + \\beta_2 eps + \\beta_3 netinc +\\beta_4 salary + u \\] data(return) Estime el modelo por MCO ¿Qué puede concluir? model1 &lt;- lm(return ~ dkr + eps + netinc + salary, data = return) stargazer(list(model1), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) Realice un test de significancia global del modelo usando un nivel de significancia de 5%. \\[ H_0: \\beta_1 = \\beta_2 = \\beta_3 = \\beta_4 = 0 \\] y la hipótesis alternativa es que por lo menos uno de los \\(\\beta_j\\) sea distinto de cero. Método 1: Usa el siguiente estadígrafo de prueba: [escribir estadígrafo] paste0(&quot;F Statistic = &quot;, round( (summary(model1)$r.squared/4)/((1-summary(model1)$r.squared)/(142-4-1)),4) ) paste0(&quot;p-value = &quot;, round(1-pf(1.4077, 4, 137),4)) Método 2: Usando el paquete car, se realiza el test de hipótesis. myH0 &lt;- c(&quot;dkr = 0&quot;, &quot;eps = 0&quot;, &quot;netinc = 0&quot;, &quot;salary = 0&quot;) linearHypothesis(model1, myH0) P3 Usted dispone de precios de ventas de casas en la ciudad de Windsor, Canada, durante los meses de Julio, Agosto y Septiembre de de 1987. [insertar tabla] data(HousePrices) ¿Cuántas observaciones hay en la base de datos? ¿Qué tipo de variable es cada una de las incluidas en la base de datos? glimpse(HousePrices) Estime el siguiente modelo de regresión lineal múltiple: [insertar ecuacion] # Modelo no restringido model_1 = lm(log(price) ~ log(lotsize) + bedrooms + bathrooms + aircon + driveway + recreation + fullbase + gasheat + garage + prefer + stories, data = HousePrices) stargazer(list(model_1), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) Interprete el significado de \\(\\beta_1, \\beta_2, \\beta_3\\) y \\(\\beta_4\\). Testee la siguiente hipótesis usando un nivel de significancia de 5%: [insertar ecuacion] y la hipótesis alternativa es que por lo menos uno de los \\(\\beta_j\\) sea distinto de cero. Método 1 Este método usa el paquete car para testear la hipótesis. my_H0 &lt;- c(&quot;drivewayyes = 0&quot;, &quot;recreationyes = 0&quot;, &quot;fullbaseyes = 0&quot;, &quot;gasheatyes = 0&quot;, &quot;garage = 0&quot;, &quot;preferyes = 0&quot;, &quot;stories = 0&quot;) linearHypothesis(model_1, my_H0) Método 2 En este método, se estimará el siguiente modelo restringido: [insertar ecuacion] El estadígrafo de prueba a usar es el siguiente: # Modelo restringido model_2 = lm(log(price) ~ log(lotsize) + bedrooms + bathrooms + aircon, data = HousePrices) stargazer(list(model_1, model_2), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) paste0(&quot;F Statistic = &quot;, round( ((summary(model_1)$r.squared-summary(model_2)$r.squared)/7)/ ((1-summary(model_1)$r.squared)/(546-11-1)),3) ) paste0(&quot;p-value = &quot;, round(1-pf(28.993, 7, 534),4)) Por lo tanto, se rechaza \\(H_0\\). Usando los resultados de la estimación del modelo ¿Cuál es el precio estimado para una casa con las características que se detallan más abajo? Si una casa con estas características se vende a un precio de 200 mil dólares canadiense ¿Recomendaría comprar la casa? [insertar tabla] El primer intento para predecir el precio de una casa es exp(log(price)). Sin embargo, subestimará de manera sistemática el valor esperado del precio. Se puede demostrar que si u ∼ N(0,σ2), entonces: [insertar ecuacion] donde \\(\\sigma^2\\) es el estimador insesgado de la varianza de u. Notas: En el output de R se presenta el error estándar de los residuos, el cual puede usarse para realizar este cálculo. Si \\(u\\sim N(0,\\sigma^2)\\), entonces el valor esperado de \\(\\exp(u)\\) es \\(\\exp(\\frac{\\sigma^2}{2})\\). Se recomienda revisar un texto de econometría para un método que pueda utilizarse cuando u no se distribuye normalmente. xpred &lt;- data.frame(lotsize = 10000, bedrooms = 4, bathrooms = 1, aircon = &quot;yes&quot;, driveway = &quot;yes&quot;, recreation = &quot;yes&quot;, fullbase = &quot;yes&quot;, gasheat = &quot;yes&quot;, garage = 2, prefer = &quot;yes&quot;, stories = 2) p &lt;- predict(model_1, xpred) paste0(&quot;Precio esperado = &quot;, round(exp(p+0.5*0.21^2))) "],["modelos-de-probabilidad-lineal-probit-y-logit.html", "Parte 9 Modelos de probabilidad lineal, probit y logit", " Parte 9 Modelos de probabilidad lineal, probit y logit "],["modelos-de-probabilidad-lineal-probit-y-logit-1.html", "Parte 10 Modelos de probabilidad lineal, probit y logit P1 P2 P3", " Parte 10 Modelos de probabilidad lineal, probit y logit P1 A continuación se analizará el efecto que tuvo la participación en un programa de capacitación laboral en la probabilidad de desempleo. El programa fue asignado aleatoriamente a un grupo de 445 hombres, quienes podían ingresar al programa a partir de enero de 1976 hasta mediados de 1977. El programa terminó en diciembre de 1977. Los datos se encuentran en el archivo jtrain2.dta. jtrain2 %&gt;% glimpse() Presente una tabla que presente la distribución de la muestra en su status de desempleo, de acuerdo a su participación en el programa. jtrain2 %&gt;% tabyl(unem78, train) %&gt;% adorn_totals(where = c(&quot;row&quot;,&quot;col&quot;)) %&gt;% adorn_title(&quot;combined&quot;) %&gt;% knitr::kable() Estime un modelo de probabilidad lineal, probit y logit para la probabilidad de desempleo como función de la participación en el programa de capacitación. model1_1 &lt;- lm(unem78 ~ train, data = jtrain2) model1_2 &lt;- glm(unem78 ~ train, family = binomial(link = &quot;probit&quot;), data = jtrain2) model1_3 &lt;- glm(unem78 ~ train, family = binomial(link = &quot;logit&quot;), data = jtrain2) stargazer(list(model1_1, model1_2, model1_3), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) Calcule los errores estándar robustos a heterocedasticidad del modelo de probabilidad lineal coeftest(model1_1, vcov = vcovHC(model1_1, type=&quot;HC1&quot;)) Calcule el efecto de la capacitación sobre la probabilidad de estar desempleado. modelo de probabilidad lineal pnorm(-0.696) pnorm(-0.375) modelo probit exp(-1.135)/(1+exp(-1.135)) exp(-0.602)/(1+exp(-0.602)) modelo logit logitmfx(unem78 ~ train, data = jtrain2, atmean=FALSE) # Average partial effect (APE) logitmfx(unem78 ~ train, data = jtrain2, atmean=TRUE) # Partial effect at the average (PEA) modelo marginal para logit probitmfx(unem78 ~ train, data = jtrain2, atmean=FALSE) # Average partial effect (APE) probitmfx(unem78 ~ train, data = jtrain2, atmean=TRUE) # Partial effect at the average (PEA) P2 Suponga que desea analizar los determinantes de la denegación de una solicitud de préstamo hipotecario. Para ello cuenta con los siguientes datos referidos a las solicitudes de hipotecas recogidas en el área de Boston, Massachusetts, en 1990: [insertar tabla] data(HMDA) glimpse(HMDA) En la década de 1990 los empleados de entidades de crédito habitualmente utilizaban valores de corte para la proporción préstamo-valor, por lo que construya las siguientes variables dummies: [insertar tramos] HMDA &lt;- HMDA %&gt;% mutate(lvrat_bajo = if_else(lvrat &lt; 0.8, 1,0), lvrat_medio = if_else(lvrat &gt;= 0.8 &amp; lvrat &lt;=0.95, 1,0), lvrat_alto = if_else(lvrat &gt; 0.95, 1,0)) Transforme a variables numéricas las variables mhist, chist y deny HMDA$mhist &lt;- as.numeric(HMDA$mhist) HMDA$chist &lt;- as.numeric(HMDA$chist) HMDA$denegar &lt;- as.numeric(HMDA$deny) HMDA &lt;- HMDA %&gt;% mutate(denegar = denegar - 1) ¿Qué porcentaje de las solicitudes de crédito hipotecario fueron denegadas? HMDA %&gt;% tabyl(deny) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% adorn_pct_formatting() %&gt;% knitr::kable() Estime un modelo de probabilidad lineal, logit y probit. # Modelo de probabilidad lineal model_linear1 &lt;- lm(denegar ~ afam + pirat + hirat + lvrat_medio + lvrat_alto + chist + mhist + phist + insurance + selfemp, data = HMDA) # Modelo logit model_logit1 &lt;- glm(denegar ~ afam + pirat + hirat + lvrat_medio + lvrat_alto + chist + mhist + phist + insurance + selfemp, family = binomial(link = &quot;logit&quot;), data = HMDA) # Modelo probit model_probit1 &lt;- glm(denegar ~ afam + pirat + hirat + lvrat_medio + lvrat_alto + chist + mhist + phist + insurance + selfemp, family = binomial(link = &quot;probit&quot;), data = HMDA) stargazer(list(model_linear1, model_logit1, model_probit1), type = &quot;latex&quot;, header = FALSE, float = FALSE, no.space = TRUE) Para el caso del modelo de probabilidad chequee si existen valores predichos menores a cero o mayores a 1 ¿Cuántas observaciones se encuentran fuera del rango 0-1? augment(model_linear1) %&gt;% summarize( n = n(), mean = mean(.fitted), sd = sd(.fitted), min = min(.fitted), p25 = quantile(.fitted, 0.25), p50 = median(.fitted), p75 = quantile(.fitted, 0.75), max = max(.fitted)) %&gt;% knitr::kable(digits = 2, booktabs = T) %&gt;% kableExtra::kable_styling() augment(model_linear1) %&gt;% filter(.fitted &lt; 0 | .fitted &gt; 1) %&gt;% count() Para el modelo de probabilidad lineal presente las estimaciones incluyendo errores estándar robustos a heterocedasticidad. coeftest(model_linear1, vcov. = vcovHC, type = &quot;HC1&quot;) P3 Un banco está interesado en entender los factores que predicen el no pago de las deudas de tarjetas de crédito para lo que cuenta con una base de datos de 10000 personas con las siguientes variables: [insertar tabla] data(Default) ¿Cuántas observaciones contiene el dataset Default?, ¿Cuántas personas default? glimpse(Default) table(Default$default) levels(Default$default) Default$default &lt;- forcats::fct_relevel(Default$default, &quot;Yes&quot;) table(Default$default) Asigne aleatoriamente el 80% de las 10000 observaciones a la muestra de entrenamiento y el 20% restante, a la muestra de prueba. set.seed(3456) # Coloca el 80 % de las observaciones en la muestra de entrenamiento default_split &lt;- Default %&gt;% initial_split(prop = 0.80, strata = default) default_train &lt;- default_split %&gt;% training() default_test &lt;- default_split %&gt;% testing() Estime el modelo logit usando la muestra de entrenamiento. # Especificación del modelo logistic_model &lt;- logistic_reg() %&gt;% set_engine(&#39;glm&#39;) %&gt;% set_mode(&#39;classification&#39;) logistic_model # Ajuste del modelo al training dataset, especificando la fórmula logistic_fit &lt;- logistic_model %&gt;% fit(default ~ student + balance + income, data = default_train) logistic_fit %&gt;% tidy() Usando la estimación del modelo logit, calcule el efecto marginal de un cambio en el balance sobre la probabilidad de default. Específicamente calcule PEA y APE. # Cálculo de Average Partial Effect logitmfx(default ~ student + balance + income, data = default_train, atmean=FALSE) # APE # Cálculo de Partial Effect at the Average logitmfx(default ~ student + balance + income, data = default_train, atmean=TRUE) # PEA Calcule las probabilidades de default y categorías predichas para la muestra de prueba # Predicciones de default = Yes o default = No class_pred &lt;- logistic_fit %&gt;% predict(new_data = default_test, type = &quot;class&quot;) # Predicciones de probabilidades de default prob_pred &lt;- logistic_fit %&gt;% predict(new_data = default_test, type = &quot;prob&quot;) prob_pred %&gt;% summarize( n = n(), mean = mean(.pred_Yes), sd = sd(.pred_Yes), min = min(.pred_Yes), p25 = quantile(.pred_Yes, 0.25), p50 = median(.pred_Yes), p75 = quantile(.pred_Yes, 0.75), max = max(.pred_Yes)) %&gt;% knitr::kable(digits = 4, booktabs = T) %&gt;% kableExtra::kable_styling() Usando la estimación del modelo logit, calcule la probabilidad de default para dos personas que difieren sólo en su calidad de estudiante. [insertar categorias] eval &lt;- tibble::tibble( student = c(&quot;Yes&quot;,&quot;No&quot;), balance = 1500, income = 40000 ) logistic_fit %&gt; % predict(new_data = eval, type = &quot;prob&quot;) [insertar ecuaciones] Calcule la matriz de confusión, sensitivity, specificity y accuracy # Evaluación del modelo default_results &lt;- default_test %&gt;% bind_cols(class_pred, prob_pred) # Matriz de confusión default_results %&gt;% conf_mat(truth = default, estimate = .pred_class) # Accuracy default_results %&gt;% accuracy(truth = default, estimate = .pred_class) # Sensitivity (tasa de verdaderos positivos) default_results %&gt;% sens(truth = default, estimate = .pred_class) # Especificity (tasa de verdaderos negativos) default_results %&gt;% spec(truth = default, estimate = .pred_class) perf_metrics &lt;- metric_set(accuracy, sens, spec) default_results %&gt;% perf_metrics(truth = default, estimate = .pred_class) Grafique la curva ROC (Receiver Operating Characteristic) Esta curva relaciona la tasa de falsos positivos (1−specificity) y la tasa de verdaderos positivos (sensitivity), calculados a partir de distintos valores para el cutoff. default_results %&gt;% roc_curve(truth = default, .pred_Yes) default_results %&gt;% roc_curve(truth = default, .pred_Yes) %&gt;% ggplot(aes(x = 1 - specificity, y = sensitivity)) + geom_line() + geom_abline(lty = &quot;dotted&quot;, colour = &quot;#797979&quot;) + coord_fixed() + theme_minimal() Una manera de resumir la información de la ROC curve en un único número es el área bajo la curva ROC conocido como AUC. Calcule el AUC. default_results %&gt;% roc_auc(truth = default, .pred_Yes) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
